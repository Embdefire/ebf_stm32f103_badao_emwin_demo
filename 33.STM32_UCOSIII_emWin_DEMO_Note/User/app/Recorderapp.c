/**************************************************************************************
* 因为emWin显示只支持UTF-8编码格式的中文，如果希望直接显示在Keil直接输入的中文，      *
*            比如使用：GUI_DispStringHCenterAt("流水灯",110,120);                     *
* 该文件必须以UTF-8编码格式，不然中文无法正常显示。                                   *
*                                                                                     *
* 如果只是个别例程出现中文显示乱码（如果所有例程都无法显示中文可能是字库问题），      *
* 把对应的例程文件(比如LEDapp.c)用电脑的记事本软件打开，然后选择另存为，在弹出对      *
* 话框中“保存(S)"按钮的左边有个"编码(E)"选项，选择"UTF-8",然后同样保存为同名称的      *
* C语言文件(覆盖原来文件)，再编译。                                                   *
*                                                                                     *
* 如果编译工程时出现下面类似错误也是该文件编码格式问题,必须把文件保存为UTF-8格式      *
* 再编译                                                                              *
* ..\..\User\app\LEDapp.c(275): error:  #8: missing closing quote                     *
*        GUI_DispStringHCenterAt("娴?姘?鐏?",110,120);                                *
* ..\..\User\app\LEDapp.c(276): error:  #165: too few arguments in function call      *
*        GUI_DispStringHCenterAt("瑙?鎽?鍋?宸?澶?鎵?闇€瑕?瑙?鎽?鏍?鍑?",110,215);     *
* ..\..\User\app\LEDapp.c(276): error:  #18: expected a ")"                           *
*        GUI_DispStringHCenterAt("瑙?鎽?鍋?宸?澶?鎵?闇€瑕?瑙?鎽?鏍?鍑?",110,215);     *
*                                                                                     *
* 修改文件后编译就出错这是Keil5软件问题(Keil4没这问题)，推荐使用其他程序编辑工具，    *
* 只用Keil5完成编译和下载工作。                                                       *
***************************************************************************************
*                      实验平台: 野火STM32 ISO 开发板                                 *
*                      论    坛: http://www.chuxue123.com                             *
*                      淘    宝: http://firestm32.taobao.com                          *
*                      邮    箱: wildfireteam@163.com                                 *
***************************************************************************************
*/
/**************************************************************************************
*                                                                                     *
*                SEGGER Microcontroller GmbH & Co. KG                                 *
*        Solutions for real time microcontroller applications                         *
*                                                                                     *
***************************************************************************************
*                                                                                     *
* C-file generated by:                                                                *
*                                                                                     *
*        GUI_Builder for emWin version 5.22                                           *
*        Compiled Jul  4 2013, 15:16:01                                               *
*        (c) 2013 Segger Microcontroller GmbH & Co. KG                                *
*                                                                                     *
***************************************************************************************
*                                                                                     *
*        Internet: www.segger.com  Support: support@segger.com                        *
*                                                                                     *
***************************************************************************************
*/
// USER START (Optionally insert additional includes)
#include "includes.h"
#include  "app.h"
// USER END
/**************************************************************************************
*
*       Defines
*
***************************************************************************************
*/
// USER START (Optionally insert additional defines)
#define BUFSIZE				512
// USER END

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/
// USER START (Optionally insert additional static data)
extern GUI_CONST_STORAGE GUI_BITMAP bmwave;
extern GUI_CONST_STORAGE GUI_BITMAP bmmic;
extern GUI_CONST_STORAGE GUI_BITMAP bmanote;

extern FIL	file;																							//文件句柄
extern FRESULT result;																				//文件系统API函数返回值
extern UINT bw;																								//已读或已写的字节数

static uint8_t Replay=0,RecordFlag=0;
static TCHAR recfilename[25]={"1:/recorder/rec000.wav"};
static uint8_t recbuf[BUFSIZE]={0};
static __WaveHeader rechead;

static char tempstr[12]={"rec000.wav"};
static WM_HWIN htime,hrecord,hreplay;
// USER END

/*********************************************************************
*
*       _aDialogCreate
*/
static const GUI_WIDGET_CREATE_INFO _aDialogCreateRecorder[] = {
  { FRAMEWIN_CreateIndirect, "Recorder",0, 0, 0, 240, 320, 0, 0x64, 0 },
  { BUTTON_CreateIndirect, "Record", GUI_ID_BUTTON0, 40, 160, 58, 58, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "Replay", GUI_ID_BUTTON1, 130, 160, 58, 58, 0, 0x0, 0 },
	{ TEXT_CreateIndirect, "Name", GUI_ID_TEXT0, 20, 60, 190, 30, 0, 0x0, 0 },
	{ TEXT_CreateIndirect, "Time", GUI_ID_TEXT1, 80, 90, 70, 20, 0, 0x0, 0 },
  // USER START (Optionally insert additional widgets)
  // USER END
};

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/
// USER START (Optionally insert additional static code)
void recorder(const TCHAR *recfile)
{
	uint8_t recagc=4;			//默认增益为4
	uint32_t sectorsize=0;
	uint16_t recsec=0;					//录音时间
	uint16_t regval=0;
	uint16_t idx=0;
	recoder_enter_rec_mode(1024*recagc);
	while(VS_RD_Reg(SPI_HDAT1)>>8);			//等到buf 较为空闲再开始

	rechead.riff.ChunkID=0X46464952;	//"RIFF"
	rechead.riff.ChunkSize=0;			//还未确定,最后需要计算
	rechead.riff.Format=0X45564157; 	//"WAVE"
	rechead.fmt.ChunkID=0X20746D66; 	//"fmt "
	rechead.fmt.ChunkSize=16; 			//大小为16个字节
	rechead.fmt.AudioFormat=0X01; 		//0X01,表示PCM;0X01,表示IMA ADPCM
 	rechead.fmt.NumOfChannels=1;		//单声道
 	rechead.fmt.SampleRate=8000;		//8Khz采样率 采样速率
 	rechead.fmt.ByteRate=rechead.fmt.SampleRate*2;//16位,即2个字节
 	rechead.fmt.BlockAlign=2;			//块大小,2个字节为一个块
 	rechead.fmt.BitsPerSample=16;		//16位PCM
  rechead.data.ChunkID=0X61746164;	//"data"
 	rechead.data.ChunkSize=0;			//数据大小,还需要计算  

	result=f_open(&file,recfile, FA_CREATE_ALWAYS | FA_WRITE); 
	if(result)
		return;
	else
		result=f_write(&file,&rechead,sizeof(__WaveHeader),&bw);//写入头数据
	printf("write result:%d,num:%d\n",result,bw);
	while(1)
	{
		if((RecordFlag==2)|| (Flag_ICON106==0))
		{
			rechead.riff.ChunkSize=sectorsize*512+36;	//整个文件的大小-8;
			rechead.data.ChunkSize=sectorsize*512;		//数据大小
			f_lseek(&file,0);							//偏移到文件头.
			result=f_write(&file,&rechead,sizeof(__WaveHeader),&bw);//写入头数据
			printf("write sector:%d,result:%d,num:%d\n",sectorsize,result,bw);
			f_close(&file);
			VS_HD_Reset();		   	//硬复位
			VS_Soft_Reset();  		//软复位 
			sectorsize=0;
			RecordFlag=0;
			return;//break;
		}
		regval=VS_RD_Reg(SPI_HDAT1);	
		if((regval>=256)&&(regval<896))
		{
			idx=0;				   	 
			while(idx<512) 	//一次读取512字节
			{	 
				regval=VS_RD_Reg(SPI_HDAT0);
				recbuf[idx]=regval&0XFF;
				recbuf[idx+1]=regval>>8;
				idx+=2;
			}	 
			f_lseek(&file,44+sectorsize*512);
			result=f_write(&file,recbuf,512,&bw);//写入文件
			if(result)
			{
				printf("err:%d\r\n",result);
				printf("bw:%d\r\n",bw);
				break;//写入出错.	  
			}
			sectorsize++;//扇区数增加1,约为32ms	 
		}
		if(recsec!=(sectorsize*4/125))//录音时间显示
		{
			recsec=sectorsize*4/125;
			sprintf(tempstr,"%02d:%02d",recsec/60,recsec%60);
			tempstr[5]='\0';
			TEXT_SetText(htime,tempstr);
		}
		WM_Exec();//GUI_Delay(1);//
	}
	//f_close(&sdfile);
}

void record_play(uint8_t *recfile)
{
	uint16_t i=0,time=0,oldtime=0;
	OS_ERR      err;
	//if(strstr((const char *)recfile,"recorder")==0)return 0xff;
	VS_HD_Reset();		   	//硬复位
	VS_Soft_Reset();  		//软复位 
	VS_Set_Vol(220);		//设置音量  				 
	VS_Reset_DecodeTime();	//复位解码时间 	 
	result=f_open(&file,(const TCHAR*)recfile,FA_READ);
	if(result==0)
	{ 
			VS_SPI_SpeedHigh();						   
			while(Replay)
			{
				i=0;	
				result=f_read(&file,recbuf,BUFSIZE,(UINT*)&bw);		
				OSSchedLock(&err);
				while(i<bw)
			  {  	
					if(VS_Send_MusicData(recbuf+i)==0)
					{
						i+=32;
					}
				}
				OSSchedUnlock(&err);
				if((bw!=BUFSIZE)||(result!=0))
				{		
					break;
				}
				GUI_Delay(1);
				if(Flag_ICON106==0)
				{					
					f_close(&file);
					return;
				}
				oldtime=f_tell(&file)/128*8/1000;
				if((time+1)<=oldtime)
				{
					time=oldtime;
					sprintf(tempstr,"%02d:%02d",time/60,time%60);
					tempstr[5]='\0';
					TEXT_SetText(htime,tempstr);
				}
			}
		}
		BUTTON_SetBitmapEx(hreplay,BUTTON_BI_UNPRESSED,&bmanote,5,5);
		TEXT_SetText(htime,"00:00");
		WM_EnableWindow(hrecord);
		Replay=0;
		f_close(&file);
}
// USER END

/*********************************************************************
*
*       _cbDialog
*/
static void _cbDialogRecorder(WM_MESSAGE * pMsg) {
  WM_HWIN hItem;
  int     NCode;
  int     Id;
  // USER START (Optionally insert additional variables)
  // USER END

  switch (pMsg->MsgId) {
		case WM_DELETE:
		OS_INFO("Recorderapp delete\n");
		Replay=0;
		RecordFlag=0;
		UserApp_Flag = 0;
	  Flag_ICON106 = 0;
	break;
  case WM_INIT_DIALOG:
    //
    // Initialization of 'Recorder'
    //
   	hItem = pMsg->hWin;
		FRAMEWIN_SetTextColor(hItem,GUI_DARKGRAY);
		FRAMEWIN_SetFont(hItem, GUI_FONT_16B_ASCII);
		FRAMEWIN_SetTextAlign(hItem, GUI_TA_LEFT | GUI_TA_VCENTER);
		FRAMEWIN_AddCloseButton(hItem,FRAMEWIN_BUTTON_RIGHT,0);
		FRAMEWIN_SetTitleHeight(hItem, 20);
    //
    // Initialization of 'Record'
    //
    hrecord = WM_GetDialogItem(pMsg->hWin, GUI_ID_BUTTON0);
    //BUTTON_SetFont(hItem, GUI_FONT_20B_ASCII);
		BUTTON_SetText(hrecord,"");
		BUTTON_SetBitmapEx(hrecord,BUTTON_BI_UNPRESSED,&bmmic,5,5);
    //
    // Initialization of 'Replay'
    //
    hreplay = WM_GetDialogItem(pMsg->hWin, GUI_ID_BUTTON1);
    //BUTTON_SetFont(hItem, GUI_FONT_20B_ASCII);
		BUTTON_SetText(hreplay,"");
		BUTTON_SetBitmapEx(hreplay,BUTTON_BI_UNPRESSED,&bmanote,5,5);
		//
		// Initialization of 'Name'
		//
		hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_TEXT0);
		TEXT_SetFont(hItem, GUI_FONT_20B_ASCII);
		TEXT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
		//
		// Initialization of 'Time'
		//
		htime = WM_GetDialogItem(pMsg->hWin, GUI_ID_TEXT1);
		TEXT_SetFont(htime, GUI_FONT_16B_ASCII);
		TEXT_SetTextAlign(htime, GUI_TA_HCENTER | GUI_TA_VCENTER);
		TEXT_SetText(htime,"00:00");
    // USER START (Optionally insert additional code for further widget initialization)
    // USER END
    break;
  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    switch(Id) {
    case GUI_ID_BUTTON0: // Notifications sent by 'Record'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
				if(RecordFlag)
				{
					RecordFlag=2;
					BUTTON_SetBitmapEx(hrecord,BUTTON_BI_UNPRESSED,&bmmic,5,5);
					TEXT_SetText(htime,"00:00");
					WM_EnableWindow(hreplay);
				}
				else
				{
					RecordFlag=1;
					BUTTON_SetBitmapEx(hrecord,BUTTON_BI_UNPRESSED,&bmwave,5,5);
					WM_DisableWindow(hreplay);
				}
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case GUI_ID_BUTTON1: // Notifications sent by 'Replay'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
				if((RecordFlag==0)&&(Replay==0))
				{
					BUTTON_SetBitmapEx(hreplay,BUTTON_BI_UNPRESSED,&bmwave,5,5);
					Replay=1;
					WM_DisableWindow(hrecord);
				}else	if(Replay)
				{
					Replay=0;
					WM_EnableWindow(hrecord);
				}
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    // USER START (Optionally insert additional code for further Ids)
    // USER END
    }
    break;
  // USER START (Optionally insert additional message handling)
	case WM_PAINT:
		GUI_SetBkColor(APPBKCOLOR);
		GUI_SetColor(APPTEXTCOLOR);
		GUI_Clear();
		GUI_DispStringHCenterAt("录音文件保存在SD卡内",110,15);
		GUI_DispStringHCenterAt("插入SD卡后重启",110,35);
		break;				
  // USER END
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       CreateRecorder
*/
void FUN_ICON106Clicked(void)
{
	uint8_t i=0;
	DIR recdir;	 					//目录
	WM_HWIN hWin;
	tempstr[10]='\0';
	recfilename[22]='\0';
	OS_INFO("Recorderapp create\n");
	VS_Init();
	GUI_Delay(10);
//	printf("vs1053:%4X\n",VS_Ram_Test());
//	GUI_Delay(100);
//	VS_Sine_Test();
	VS_HD_Reset();
	VS_Soft_Reset();	
	result=f_opendir(&recdir,"1:/recorder");
//	printf("opendir_res:%d\n",result);
	while(result!=FR_OK)
	{
		f_mkdir("1:/recorder");				//创建该目录 
		result=f_opendir(&recdir,"1:/recorder");
//		printf("opendir_res:%d\n",result);
	}
//	f_closedir(&recdir);
	hWin=GUI_CreateDialogBox(_aDialogCreateRecorder, GUI_COUNTOF(_aDialogCreateRecorder), _cbDialogRecorder, WM_HBKWIN, 0, 0);
	
	
	
	while(Flag_ICON106)
	{
		if(RecordFlag==1)
		{
			i=0;
			while(i<0xff)
			{
				sprintf((char *)recfilename,"1:/recorder/rec%03d.wav",i);
				result=f_open(&file,(const TCHAR*)recfilename,FA_READ);
				//printf("f_open_res:%d\n",result);
				if(result==FR_NO_FILE)break;	
				else
						f_close(&file);
				i++;
			}
			//printf("record:filename:%s\n",recfilename);
			if(i==0xff)
			{
				RecordFlag=0;
				continue;
			}
			sprintf((char *)tempstr,"rec%03d.wav",i);
			tempstr[10]='\0';
			TEXT_SetText(WM_GetDialogItem(hWin, GUI_ID_TEXT0),tempstr);
			recorder((const TCHAR*)recfilename);				
		}
		if((RecordFlag==0)&&(Replay==1))
		{
			sprintf((char *)tempstr,"rec%03d.wav",i);
			tempstr[10]='\0';
			TEXT_SetText(WM_GetDialogItem(hWin, GUI_ID_TEXT0),tempstr);			
			//printf("play:filename:%s\n",recfilename);
			record_play((uint8_t *)recfilename);
		}
		GUI_Delay(10);
	}
}

// USER START (Optionally insert additional public code)
// USER END

/*************************** End of file ****************************/
